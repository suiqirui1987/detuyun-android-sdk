/** * com.detuyun.api.utils * PolicyUtils.java */package com.detuyun.api.utils;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.HashMap;import java.util.Set;import org.json.JSONException;import org.json.JSONObject;/** * DetuYunUtils.java *  * @author vincent chen * @since 2012 Jun 27, 2012 10:40:13 AM */public class DetuYunUtils {	/**	 * saveKey表示在服务器上存储文件的位置和文件名，如果服务器上已有同名文件，将会默认直接覆盖原有文件。 通常使用	 * “/filepath/filename” 的形式来保存文件。 expiration表示过期时间，使用的是unix time bucket	 * 表示云存储的空间名	 * 	 * @param saveKey	 * @param expiration	 * @param bucket	 * @return	 */	public static String makePolicy(String saveKey, long expiration, String bucket) throws DetuYunException {		return makePolicy(saveKey, expiration, bucket, null);	}	/**	 * saveKey表示在服务器上存储文件的位置和文件名，如果服务器上已有同名文件，将会默认直接覆盖原有文件。 通常使用	 * “/filepath/filename” 的形式来保存文件。 expiration表示过期时间，使用的是unix time bucket	 * 表示云存储的空间名 params 其他参数请参考得图云的api文档	 * 	 * @param saveKey	 * @param expiration	 * @param bucket	 * @param params	 * @return	 * @throws DetuYunException	 */	public static String makePolicy(String access_key, long expiration, String bucket, HashMap<String, Object> params)			throws DetuYunException {		if (access_key == null || access_key.equals("")) {			throw new DetuYunException(20, "miss param access_key");		}		if (expiration == 0) {			throw new DetuYunException(20, "miss param expiration");		}		if (bucket == null || bucket.equals("")) {			throw new DetuYunException(20, "miss param bucket");		}		JSONObject obj = new JSONObject();		try {			obj.put("access_key", access_key);			obj.put("expiration", expiration);			obj.put("bucket", bucket);			if (params != null) {				Set<String> keys = params.keySet();				for (String key : keys) {					obj.put(key, params.get(key));				}			}		} catch (JSONException e) {			throw new DetuYunException(21, e.getMessage());		}				return Base64Coder.encodeString(obj.toString());	}	/**	 * source String = "policy + & + 表单API验证密钥" 获得签名数据	 * <b>通常我们建议签名数据在服务器端生成，仅在手机端需要上传文件的时候，才从服务器端取得签名后的数据，以防止表单API验证密钥泄露出去。</b>	 * 	 * @param source	 * @return	 */	public static String signature(String source) {		try {			MessageDigest md = MessageDigest.getInstance("MD5");			md.reset();			md.update(source.getBytes());			byte[] mdbytes = md.digest();			StringBuffer hexString = new StringBuffer();			for (int i = 0; i < mdbytes.length; i++) {				String hex = Integer.toHexString(0xff & mdbytes[i]);				if (hex.length() == 1)					hexString.append('0');				hexString.append(hex);			}			return hexString.toString();		} catch (NoSuchAlgorithmException e) {			e.printStackTrace();		}		return null;	}		public static String getResultString(HashMap<String, Object> map)	{						String resultString = "";		String x_detuyun_width = getDecodeString(map.get("x-detuyun-width").toString());		if(!isNullOrEmpty(x_detuyun_width))		{			resultString += "图片宽度："+x_detuyun_width+"\n";		}				String x_detuyun_height = getDecodeString(map.get("x-detuyun-height").toString());		if(!isNullOrEmpty(x_detuyun_height))		{			resultString += "图片高度："+x_detuyun_height+"\n";		}				if(map.containsKey("x-detuyun-type")){		String x_detuyun_type = getDecodeString(map.get("x-detuyun-type").toString());		if(!isNullOrEmpty(x_detuyun_type))		{			resultString += "图片类型："+x_detuyun_type+"\n";		}		}		String x_detuyun_frames = getDecodeString(map.get("x-detuyun-frames").toString());		if(!isNullOrEmpty(x_detuyun_frames))		{			resultString += "图片帧数："+x_detuyun_frames+"\n";		}				String x_detuyun_filepath = getDecodeString(map.get("x-detuyun-filepath").toString());		if(!isNullOrEmpty(x_detuyun_filepath))		{			resultString += "图片路径："+x_detuyun_filepath+"\n";		}				return resultString;	}		static boolean isNullOrEmpty(String str)	{		if(str == null || str.length() == 0)		{			return true;		}		return false;	}		public static String getDecodeString(String str)	{		java.net.URLDecoder ud = new URLDecoder();		try {			str = ud.decode(str,"utf-8");		} catch (UnsupportedEncodingException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}		return str;	}	}